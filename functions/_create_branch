#!/bin/bash

createBranch () {
  local commitMsg=""
  local branchName=""
  local baseBranch=""

  toSlug() {
    local s="${1}"
    printf '%s' "${s}" \
      | tr '[:upper:]' '[:lower:]' \
      | sed -E \
          -e 's/[_[:space:]]+/-/g' \
          -e 's/[^a-z0-9-]+/-/g' \
          -e 's/-+/-/g' \
          -e 's/^-+//; s/-+$//'
  }

  trim() {
    printf '%s' "${1}" | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//'
  }

  deriveBranchFromCommit() {
    local msg="${1}"
    local type=""
    local rest=""

    [[ "${msg}" == *:* ]] || return 1

    type="$(trim "${msg%%:*}")"
    rest="$(trim "${msg#*:}")"

    type="$(toSlug "${type}")"
    rest="$(toSlug "${rest}")"

    [[ -n "${type}" && -n "${rest}" ]] || return 1
    printf '%s/%s' "${type}" "${rest}"
  }

  detectBaseBranch() {
    local remoteHead=""

    remoteHead="$(git symbolic-ref -q --short refs/remotes/origin/HEAD 2>/dev/null || true)"
    if [[ -n "${remoteHead}" ]]; then
      # validate the target exists; origin/HEAD can be stale
      if git show-ref --verify --quiet "refs/remotes/${remoteHead}"; then
        printf '%s' "${remoteHead#origin/}"
        return 0
      fi
    fi

    # prefer local branches
    if git show-ref --verify --quiet refs/heads/master; then
      printf '%s' "master"
      return 0
    fi
    if git show-ref --verify --quiet refs/heads/main; then
      printf '%s' "main"
      return 0
    fi

    # then fall back to remote-tracking branches
    if git show-ref --verify --quiet refs/remotes/origin/master; then
      printf '%s' "master"
      return 0
    fi
    if git show-ref --verify --quiet refs/remotes/origin/main; then
      printf '%s' "main"
      return 0
    fi

    return 1
  }

  while [[ ${#} -gt 0 ]]; do
    case "${1}" in
      --commit)
        shift
        commitMsg="${1}"
        shift
        ;;
      --branch)
        shift
        branchName="${1}"
        shift
        ;;
      *)
        branchName="${1}"
        shift
        ;;
    esac
  done

  if [[ -z "${commitMsg}" ]]; then
    echo "Missing commit message"
    return 1
  fi

  if [[ -z "${branchName}" ]]; then
    branchName="$(deriveBranchFromCommit "${commitMsg}")" || {
      echo "Missing branch name, and couldn't derive one from commit message."
      echo "Expected commit format: 'type: text' (e.g. 'feat: add thing')."
      return 1
    }
  fi

  baseBranch="$(detectBaseBranch)" || {
    echo "Could not determine base branch (expected origin/HEAD, or main/master)."
    return 1
  }

  echo "Checking out ${baseBranch}"
  git checkout "${baseBranch}" || return 1

  echo "Pulling latest changes"
  git pull || return 1

  echo "Creating new branch: ${branchName}"
  git checkout -b "${branchName}" || return 1

  echo "Committing staged changes as '${commitMsg}'"
  git commit -m "${commitMsg}" || return 1

  local pushOutput=""
  pushOutput="$(git push --set-upstream origin "${branchName}" 2>&1)"
  if ! [[ ${?} -eq 0 ]]; then
    echo "error pushing to origin"
    echo "${pushOutput}"
    return 1
  fi

  echo "${pushOutput}"

  local mergeRequestUrl=""
  local mrTitle="${branchName}"
  mergeRequestUrl="$(echo "${pushOutput}" | awk '/https/ {print $2}')&merge_request%5Btitle%5D=${mrTitle}"

  echo "${mergeRequestUrl}"
  brave --new-window "${mergeRequestUrl}"
}
